\chapter{Background}  % Motivation
\label{chap:background}

\begin{chapquote}{Satoshi Nakamoto}
The nature of Bitcoin is such that once version 0.1 was released, the core design was set in stone for the rest of its lifetime. 
\end{chapquote}

\section{What is Bitcoin?}
The word ``Bitcoin'' is used to represent all of the following:
\begin{itemize}
    \item A specific computer program.
    \item A peer to peer network of nodes that run the program.
    \item The protocol that governs how these nodes operate with each other.
    \item The numerical value that is transferred through the network based on the rules of the program. We will use bitcoin with a lower case ``b'' to refer to this numeric unit.
\end{itemize}

Satoshi Nakamoto released the first version \cite{satoshi_bitcoin_release_0_1_0} of the software in January 2009, and also ran the software on a computer that he controlled. He was soon joined by Hal Finney, who ran the same software and connected the software instance running on his computer (his node) to Nakamoto's node using classic a TCP/IP network connection. Later, other users started running the same software and connected to this growing peer to peer network. Crucially, anyone who has access to a computer and the internet can run the software and connect to the Bitcoin network. 

\section{What does a Bitcoin node do?}
Note that this section will feature definitions where some of the terms used in the definition are themselves defined later on. Such terms will be italicized. 

Like any complex piece of software, a Bitcoin node does a variety of things. When it starts fresh, it connects to other nodes over the standard networking stack to download the \textit{blockchain} to synchronize itself to the current global state of Bitcoin. The blockchain is the database of every historical \textit{transaction} that has happened in Bitcoin since Nakamoto's famous first transaction that gave him the ability to spend 50 bitcoins. 

A  transaction refers to one or more previous transactions, which are called its inputs. It also has one or more outputs, which are a combination of some bitcoin value and a \textit{spending condition} that locks this output. A transaction is valid if it has special data that shows that the spending conditions of each input is met and the total sum of output values do not exceed the total sum of the input values. The base case of such a recursive definition of transactions is the so called coinbase transaction, which has no inputs. Its value comes from the protocol, where fresh bitcoins are minted every \textit{block} and given to the \textit{miner} who \textit{mines} that block. This amount is called the ``block subsidy''. Additionally, the difference in bitcoin value between the inputs and outputs are also added to the block subsidy to make up the total block reward that goes to the miner.

Spending conditions and the special data that satisfies a spending condition are called scriptPubKey and scriptSig/witness in Bitcoin. These are both typically cryptographic in nature. For example, a standard scriptPubKey is of the type Pay-2-Public-Key (P2PK) and is just a public key. A transaction that spends a P2PK output has to provide a signature from the corresponding private key. In this case, this signature is the scriptSig. Every transaction has to provide scriptSigs to the corresponding scriptPubKeys of the inputs. Every transaction has to lock its own outputs with new scriptPubKeys. scriptPubKeys and scriptSigs are are written in a concise language called Bitcoin Script that provides involve basic operations like checking digital signatures, comparing whether two strings are equal, calculating the hash of a string, etc. Outputs can also be locked using timelocks. A transaction that spends a timelocked output can only be confirmed at certain times whose rules are defined in the timelock. 

A block is a set of transactions that is accepted by every node running Bitcoin as probabilistically confirmed. To be accepted, a block needs to have a valid \textit{block header} and a set of valid transactions that do not conflict with transactions from previously confirmed blocks. A valid block header is a tuple with a hash that demonstrates valid \textit{proof of work}, a valid timestamp, reference to a previous valid block, and the Merkle root of all transactions that are included in the block. The blockchain is called as such because it forms a chain of blocks with the current block referring to a previous block and so on, all the way to the genesis block. The genesis block's data is hardcoded in the Bitcoin software. 

A miner is a special node which listens to various unconfirmed transactions propagating in the network, makes a set of such transactions that are valid and consistent with a previously confirmed block that they know about. Together, these give the miner an incomplete block header. After this, the miner tries to find a nonce (number used only once) through trial and error which when appended to the incomplete block header such that the hash of the block header is lower than the \textit{difficulty parameter}. This trial and error process is typically done on specialized hardware, and consumes a lot of electricity - and is called mining. The entire process of mining is just about trying to hash an 80 byte block header such that the output of the hash function, when treated as an integer, is lower than the difficulty parameter. This is sometimes called ``Proof of Work''.

The difficulty parameter is a number that all nodes can independently derive based on the timestamps of the previous 2016 blocks. If these previous blocks have been mined faster (or slower) than the targetted average of 10 minutes per block, the difficulty number in the next block has to go up (or down). This difficulty parameter is also stored in the block header, and if that number doesn't follow the rules outlined above, that specific block is rejected by all nodes in the network. Given two blockchains with conflicting transactions somewhere along the chain from genesis to the present moment, the chain with the most accumulated work is considered valid by every node.

The set of rules that govern whether a block that is newly seen by a node is valid or not is called the consensus rules of Bitcoin. These rules govern the timestamp, the difficulty parameter, the size of the block, the validity of all transactions that are included in the block and so forth. If a miner creates an invalid block, all the electricity that they have expended to find the right nonce is wasted. If other nodes running the Bitcoin software do not recognize their block as valid, that block's coinbase reward bitcoins will not be respected by those nodes. It is understood that everyone in the ecosystem, including merchants, users, intermediaries, and whoever cares about receiving Bitcoin runs a node so that they can verify for themselves that a transaction paying them was included in a valid block.

Every node processes the blockchain from the genesis block to the current moment, validating block headers, blocks, and transactions - while building an internal data structure of the current set of outputs that are not yet spent. This is Bitcoin's current state of the world, and is called the Unspent Transaction Output set, or the UTXO set. Bitcoin is also said to follow the UTXO model of transactions, where every transactions consumes some UTXO's as inputs, and creates new UTXO's as outputs. The scriptPubKeys of the spent input UTXO's do not influence the new scriptPubKeys of the newly created output UTXO's. As said in the introduction in Chapter \ref{chap:intro}, this lack of ``condition continuation'' across transactions prevent Bitcoin from supporting rich stateful smart contracts.

\section{HTLC}
HTLC's are a simple type of smart contract that use preimage resistance of cryptographic hash functions, along with timelocks, to enable an escrow service. Say we have a buyer who has some bitcoin and wants to buy some goods/services from a seller. The buyer commits their bitcoin into a contract which is locked by an OR condition of:
\begin{itemize}
    \item Preimage to a cryptographic hash. This is the payment path. The buyer creates a random secret preimage and cryptographically hashes it to get a digest. This digest is used to lock the payment path. The buyer will reveal the preimage to the seller once the buyer has possession of the goods/services. The seller can use this preimage and their own signature to send the funds to an public key they control. The exchange of the preimage for the goods/services can be implemented in a variety of ways, leading to different applications.
    \item A timelock. This is the refund path. The buyer sets a timelock after which the funds are refunded back. This path is to ensure that the funds do not get locked in the contract if the seller aborts. 
\end{itemize}

This transaction (\htlctxn{}) is broadcast and is confirmed on the Bitcoin blockchain to a sufficient depth to be considered finalized. The seller then exchanges their goods and services for the preimage of the hash from the buyer. This exchange process is independent of the transaction itself. Each application that uses HTLC's has its own way of doing this exchange. For example, Atomic Swaps rely on the public blockchain to reveal the secret preimage. After the exchange is done, the seller will attempt to move the UTXO created in \htlctxn{}'s payment path to a public key that the seller controls with a simpler unencumbered transaction (\sellertxn{}) that uses the seller's signature and the preimage received from the buyer. If the exchange is not done, the buyer waits for the timelock to expire, and uses the \refundtxn{} to send the funds back to themselves.

\section{Bitcoin's Transaction Notation}
In this thesis, we use the transaction/predicate notation for Bitcoin's UTXO based transactions from the Cerberus Channels paper \cite{cerberus}. We let $o = (x\,|\,P)$ to represent a UTXO that holds value $x$ and lists a predicate $P$ that locks or unlocks this UTXO. Predicate $P$ can be a base predicate (see list below) or a combination of base predicates with $\lor$ (\textit{OR}) or $\land$ (\textit{AND}) operators.
\begin{itemize}
    \item $\sigma_a$: Signature that matches\footnote{Bitcoin uses SIGHASH flags to control which part of a transaction is signed by whom. For simplicity, we assume what is being signed is clear from the context.} the public key $A$.
    \item $s \ni h(s) = H_s$: The spending transaction needs to provide a preimage $s$ whose hashed value is $H_s$.
    \item $\Delta_k$: A timelock of $k$ blocks needs to elapse to unlock the spending transaction.
\end{itemize}
A transaction is a mapping from a set of past UTXO's to a set future UTXO's, and can be represented as:
$$T_i = [o_j, o_k, \ldots] \mapsto [o_i^1, o_i^2, \ldots]$$
where $T_i$ consumes past UTXO's $o_j$, $o_k$, $\ldots$. to produce future UTXO's $\{o_i^1$, $o_i^2$, $\ldots\}$. Predicates that apprear on the left side of a transaction unlock the UTXOs in question, and those that appear on the right side lock the newly created UTXO's. An example transaction would look like:
$$T_i = [(2\,|\sigma_a), \underbrace{(1\,|\,\Delta_{10}), (3\,|s_x)}_{T_j}] \mapsto [(6\,|\,\sigma_b \land H_{s_y})]$$
$T_i$ is spending 3 UTXO's by providing a signature $\sigma_a$ for $A$ (Alice), waiting for time $\Delta_{10}$ (10 blocks), and a preimage $s_x$ such that the hash $h(s_x)$ was used to lock the 3rd UTXO that $T_i$ is spending. $T_i$ itself creates a new UTXO that has the coin value of 6, and can be spent by providing a signature for $B$ (Bob) and a preimage $s_y$ such that the hash $h(s_y) = H_{s_y}$. Additionally, the two spent UTXO's $(1\,|\,\Delta_{10}), (3\,|s_x)$ were created in a previous transaction $T_j$. The UTXO creating transaction (in the underbrace) is shown only if it is relevant to the context. In the above case, the UTXO $(2|\sigma_a)$ doesn't show a source UTXO under it, and can be assumed that the transaction from where Alice got her 2 bitcoins doesn't matter in this setting. 

\section{Atomic Swaps}
Before Bitcoin, there was considerable research on the \textit{Fair Exchange Problem}, with its associated impossibility results \cite{cleve1986limits}, \cite{fair_exchange_impossibility}, \cite{franklin1997fair}, \cite{asokan1998optimistic}. Many of these results came about in the quest to remove the \textit{trusted third party} when two parties want to exchange different assets of equal value. Bitcoin created a different kind of trusted third party. Here, both parties trust the Bitcoin blockchain as an arbiter for dispute resolution and as a tamperproof public bulletin board. Fair Exchange, in the Bitcoin setting, is known as the Atomic Swap. It is atomic in the sense that a swap of assets between two parties either goes through fully or not at all. Atomic Swaps were perhaps the first non-trivial smart contracts designed to work on blockchains. Tier Nolan's classic swap (TN-swap, from here on) was discussed on the BitoinTalk forum in 2013 \cite{atomic_swap}. The TN-swap is not atomic from a transaction perspective. The swap requires 4 transactions: 2 HTLCs + (2 redeems or 2 refunds). The atomicity is from a higher abstraction of the swap of assets -- either the swap goes through, and both parties end up with the assets they desire, or it does not, and both parties retain their original assets. These assets could even be on different blockchains, e.g., Bitcoin and Litecoin. If it were a cross-chain atomic swap, both blockchains must be compatible with the primitives used in the swap protocol. 

In Tier Nolan's classic swap (TN-swap), Alice locks amount $P_a$ with a timelock (refunding $P_a$ back to her) and a hashlock (so Bob can redeem $P_a$). Bob locks amount $P_b$ symmetrically but with a lower value for the timelock. If one of the parties aborts, the other party can wait for their timelock to expire and refund their principals back to themselves. If neither party aborts, the swap completes with both parties redeeming the principals due to them. The blockchain acts as a public bulletin board that communicates the secret preimage of the hashlock from Alice to Bob. Alice's timelock is always longer than Bob's to account for Alice's head start in the protocol and knowing the preimage of the hashlock, which enables her to finish her side of the swap first. We use the word \textit{refund} when a party's principal comes back to them after a swap is abandoned, and the word \textit{redeem} when a party can complete a swap and get the counterparty's principal. The entire set of transactions that make up the TN-swap can be defined succinctly in our notation as shown in Figure \ref{fig:tier_nolan_atomic_swap}. Transactions are referred to as $T_i$. The set of transactions that make up the successful swap, and the two failure scenarios are also shown in the same figure.

\begin{figure}[!htb!]
    \centering
    \caption{Tier Nolan Atomic Swap}
    \label{fig:tier_nolan_atomic_swap}
\begin{align*}
    &T_0 = [(P_a|\sigma_a)] \mapsto [(P_a|(\sigma_a \land \Delta_2) \lor (\sigma_b \land H_{s}))] \\
    &T_1 = [(P_b|\sigma_b)] \mapsto [(P_b|(\sigma_a \land H_{s}) \lor (\sigma_b \land \Delta_1))] \\
    &T_2 = [\underbrace{(P_b|(\sigma_a \land s))}_{T_1}] \mapsto [(P_b|\sigma_a)]\\
    &T_3 = [\underbrace{(P_a|(\sigma_b \land s))}_{T_0}] \mapsto [(P_a|\sigma_b)]\\
    &T_4 = [\underbrace{(P_b|(\sigma_b \land \Delta_1))}_{T_1}] \mapsto [(P_b|(\sigma_b)] \\
    &T_5 = [\underbrace{(P_a|(\sigma_a \land \Delta_2))}_{T_1}] \mapsto [(P_a|(\sigma_a)] \\
    &Success = \{T_0, T_1, T_2, T_3\} \\
    &Failure_1 = \{T_0, T_5\} \\
    &\text{\parbox{8cm}{[Bob aborts before committing $P_b$. Alice has to wait for $\Delta_2$, and gets no compensation]}} \\
    &Failure_2 = \{T_0, T_1, T_4\} \\
    &\text{\parbox{8cm}{[Alice aborts before redeeming $P_b$. Bob has to wait for $\Delta_1$, and gets no compensation]}}
\end{align*}
\end{figure}

\section{Payment Channels and the Lightning Network}
To be able to process more Bitcoin transactions, one may increase the block size and/or decrease the time between two blocks to achieve a higher throughput. However, these are consensus rule changes, and as such not easy to implement. Changing these parameters also adversely affect other security aspects of the Bitcoin network \cite{gervais2016security}. 

Another approach is to somehow having most transactions skip the Bitcoin blockchain itself, but still be confirmed with the same settlement guarantees as that given by the base blockchain with its proof of work. Duplex Micropayment Channels \cite{decker_wattenhofer} and the Lightning Channels \cite{poon_dryja} are two such constructions that allow for higher throughput without changing Bitcoin's consensus rules. The idea of both these protocols is to handle most transactions outside the blockchain, in so-called channels. Bitcoin users would build a network of channels between them, and most transactions are handled in these channels. The Bitcoin blockchain would only be needed to setup and close these channels, and in this meta role, it handles far less transactions. 

The Lightning Network is a peer to peer network of nodes running a version of the Lightning node software. There are implementations of the Lightning software from multiple teams of developers and researchers (LND \cite{lnd}, Eclair \cite{eclair}, Core-Lightning \cite{c_lightning}, LIT \cite{lit}), all implementing the same specifications \cite{bolt}. Each peer is connected to other peers through a specific construct called a payment channel.

A payment channel is opened with a Bitcoin transaction that commits UTXOs (Unspent Transaction Outputs) controlled by two parties into a single output that is now controlled by a ``multisig'' that both parties have to sign to be able to spend in a future transaction. This is called the opening transaction (\topen{}). Once the payment channel is opened, the two parties exchange signed Bitcoin transactions between each other over any other internet protocol. In these signed transactions, the total value of \topen{} is allotted to each party depending on how the parties want value to flow between them. For example, if the payment channel was opened with 5 BTC from Alice and 10 BTC from Bob, a subsequent state might split the total 15 BTC of the channel so that Alice gets 7 BTC and Bob gets 8 BTC. This new split indicates a 2 BTC value flow from Bob to Alice, possibly for some goods or service that Bob received from Alice. This new division of \topen{}'s balance is established by Alice and Bob by exchanging partially signed commitment transactions (\ctx{}'s) with each other that they can sign themselves and broadcast later. At this point, the payment channel can also be closed with a closing transaction if both Alice and Bob agree to it. This is done by signing the multisig UTXO created by \topen{} and sending 7 BTC to Alice and 8 BTC to Bob. 

Typically, a channel is kept open by exchanging further \ctx{}'s that change the division of the balance between Alice and Bob as more goods and services go from Alice to Bob or vice versa. Note that at any time, if either party goes permanently offline, the counterparty can sign and broadcast their latest \ctx{} to ``commit'' the latest state of the channel to the blockchain. The ability to unilaterally close the channel in case the other party goes offline makes this construction trustless. As a penalty for unilaterally closing the channel, the broadcasting party is made to wait for a timelock, whereas the counterparty (the one who might have gone offline) gets to spend their share of the channel instantly. This setup can be argued to be fair, because if a party broadcasts their \ctx{} even if the counterparty is online, they get their share of the balance, but have to wait to spend it. The counterparty does not have to wait in this case.

Importantly, a party can try to unilaterally close a channel with a \ctx{} (say, \previousctx{}) that is not the latest agreed upon \ctx{} (say, \latestctx{}). Every party potentially has many such \previousctx{}'s in their storage going back all the way to the channel opening. This allows the dishonest party to cheat the honest counterparty by picking an old, more favorable \previousctx{} from the past and broadcasting it. Lightning channels handle this cheating possibility by allowing \latestctx{} to be exchanged only if they are also accompanied by ways of revoking the immediate \previousctx{}. This revocation is handled through a revocation key that can allot the entire channel balance to the victim's control. This gives both parties a strong incentive to be honest. In case Alice tries to cheat by publishing a \previousctx{}, Alice does not get her share of the channel balance immediately because it is timelocked, thereby giving Bob a time window to penalize this cheating \previousctx{}. Bob looks up its corresponding revocation key that he got from Alice earlier, and uses it to construct the so-called justice transaction (\jtx{}) to penalize this \previousctx{}. To be able to detect cheating, Bob has to monitor the blockchain for all \previousctx{} so that he can then construct the corresponding \jtx{} and broadcast it. This is possible only if Bob is online whenever a new Bitcoin block is mined. If Bob is offline, Alice can cheat Bob by broadcasting a \previousctx{} that is more favorable to her than the current channel balance reflected in the \latestctx{}. 

