\chapter{Background}  % Motivation
\label{chap:background}

\begin{chapquote}{Satoshi Nakamoto}
The nature of Bitcoin is such that once version 0.1 was released, the core design was set in stone for the rest of its lifetime. 
\end{chapquote}

\section{What is Bitcoin?}
The word ``Bitcoin'' is used to represent all of the following:
\begin{itemize}
    \item A specific computer program.
    \item A peer to peer network of nodes that run the program.
    \item The protocol that governs how these nodes operate with each other.
    \item The numerical value that is transferred through the network based on the rules of the program. We will use bitcoin with a lower case ``b'' to refer to this numeric unit.
\end{itemize}

Satoshi Nakamoto released the first version \cite{satoshi_bitcoin_release_0_1_0} of the software in January 2009, and also ran the software on a computer that he controlled. He was soon joined by Hal Finney, who ran the same software and connected the software instance running on his computer (his node) to Nakamoto's node using classic a TCP/IP network connection. Later, other users started running the same software and connected to this growing peer to peer network. Crucially, anyone who has access to a computer and the internet can run the software and connect to the Bitcoin network. 

\section{What does a Bitcoin node do?}
Note that this section will feature definitions where some of the terms used in the definition are themselves defined later on. Such terms will be italicized. 

Like any complex piece of software, a Bitcoin node does a variety of things. When it starts fresh, it connects to other nodes over the standard networking stack to download the \textit{blockchain} to synchronize itself to the current global state of Bitcoin. The blockchain is the database of every historical \textit{transaction} that has happened in Bitcoin since Nakamoto's famous first transaction that gave him the ability to spend 50 bitcoins. 

A  transaction refers to one or more previous transactions, which are called its inputs. It also has one or more outputs, which are a combination of some bitcoin value and a \textit{spending condition} that locks this output. A transaction is valid if it has data that shows that the spending conditions of each input is met and the total sum of output values do not exceed the total sum of the input values. The base case of such a recursive definition of transactions is the so called coinbase transaction, which has no inputs. Its value comes from the protocol, where fresh bitcoins are minted every \textit{block} and given to the \textit{miner} who \textit{mines} that block. The difference in bitcoin value between the inputs and outputs are also added to the coinbase transaction's initial value.

Spending conditions are typically cryptographic in nature. For example, a standard spending condition called Pay2PublicKey needs the transaction creator to sign the transaction with the corresponding private key of the public key that was used to lock the input. Note that this input was the output of some other transaction, and was thus locked when that previous transaction was confirmed. Every transaction has to unlock its inputs, and provide locking conditions to its outputs. Locking and unlocking conditions can involve basic operations like checking digital signatures, comparing whether two strings are equal, calculating the hash of a string, and other basic operations. Locking conditions involving time are called timelocks. These conditions together make up a Bitcoin scripting language, which is used to program Bitcoin smart contracts.

A block is a set of transactions that is accepted by every node running Bitcoin as probabilistically confirmed. To be accepted, a block needs to have a valid \textit{block header} and a set of valid transactions that do not conflict with transactions from previously confirmed blocks. A valid block header is a tuple with a hash that demonstrates valid \textit{proof of work}, a valid timestamp, reference to a previous valid block, and the Merkle root of all transactions that are included in the block. The blockchain is called as such because it forms a chain of blocks with the current block referring to a previous block and so on, all the way to the genesis block. The genesis block's data is hardcoded in the Bitcoin software. 

A miner is a special node which listens to various unconfirmed transactions propagating in the network, makes a set of such transactions that are valid and consistent with a previously confirmed block that they know about. Together, these give the miner an incomplete block header. After this, the miner tries to find a nonce (number used only once) through trial and error which when appended to the incomplete block header such that the hash of the block header is lower than the \textit{difficulty parameter}. This trial and error process is typically done on specialized hardware, and consumes a lot of electricity - and is called mining. The entire process of mining is just about trying to hash an 80 byte block header such that the output of the hash function, when treated as an integer, is lower than the difficulty parameter. This is sometimes called ``Proof of Work''.

The difficulty parameter is a number that all nodes can independently derive based on the timestamps of the previous 2016 blocks. If these previous blocks have been mined faster (or slower) than the targetted average of 10 minutes per block, the difficulty number in the next block has to go up (or down). This difficulty parameter is also stored in the block header, and if that number doesn't follow the rules outlined above, that specific block is rejected by all nodes in the network. Given two blockchains with conflicting transactions somewhere along the chain from genesis to the present moment, the chain with the most accumulated work is considered valid by every node.

The set of rules that govern whether a block that is newly seen by a node is valid or not is called the consensus rules of Bitcoin. These rules govern the timestamp, the difficulty parameter, the size of the block, the validity of all transactions that are included in the block and so forth. If a miner creates an invalid block, all the electricity that they have expended to find the right nonce is wasted. If other nodes running the Bitcoin software do not recognize their block as valid, that block's coinbase reward bitcoins will not be respected by those nodes. It is understood that everyone in the ecosystem, including merchants, users, intermediaries, and whoever cares about receiving Bitcoin runs a node so that they can verify for themselves that a transaction paying them was included in a valid block.

Every node processes the blockchain from the genesis block to the current moment, validating block headers, blocks, and transactions - while building an internal data structure of the current set of outputs that are not yet spent. This is Bitcoin's current state of the world, and is called the Unspent Transaction Output set, or the UTXO set. Bitcoin is also said to follow the UTXO model of transactions, where every transactions consumes some UTXO's as inputs, and creates new UTXO's as outputs. The spending conditions of the spent input UTXO's do not influence the spending conditions of the newly created output UTXO's. As said in the introduction in Chapter \ref{chap:intro}, this lack of ``condition continuation'' across transactions prevent Bitcoin from supporting rich stateful smart contracts.

\section{HTLC}
HTLC's are a simple type of smart contract that use preimage resistance of cryptographic hash functions, along with timelocks, to enable an escrow service. Say we have a buyer who has some bitcoin and wants to buy some goods/services from a seller. The buyer commits their bitcoin into a contract which is locked by an OR condition of:
\begin{itemize}
    \item Preimage to a cryptographic hash. This is the payment path. The buyer creates a random secret preimage and cryptographically hashes it to get a digest. This digest is used to lock the payment path. The buyer will reveal the preimage to the seller once the buyer has possession of the goods/services. The seller can use this preimage and their own signature to send the funds to an address they control. The exchange of the preimage for the goods/services can be implemented in a variety of ways, leading to different applications.
    \item A timelock. This is the refund path. The buyer sets a timelock after which the funds are refunded back. This path is to ensure that the funds do not get locked in the contract if the seller aborts. 
\end{itemize}

This transaction (\htlctxn{}) is broadcast and is confirmed on the Bitcoin blockchain to a sufficient depth to be considered finalized. The seller then exchanges their goods and services for the preimage of the hash from the buyer. This exchange process is independent of the transaction itself. Each application that uses HTLC's has its own way of doing this exchange. For example, Atomic Swaps rely on another public blockchain to reveal the secret preimage. After the exchange is done, the seller will attempt to move the UTXO created in \htlctxn{}'s payment path to an address that the seller controls with a simpler unencumbered transaction (\sellertxn{}) that uses the seller's signature and the preimage received from the buyer. If the exchange is not done, the buyer waits for the timelock to expire, and uses the \refundtxn{} to send the funds back to themselves.

\section{Bitcoin's Transaction Notation}
In this thesis, we use the transaction/predicate notation for Bitcoin's UTXO based transactions from the Cerberus Channels paper \cite{cerberus}. We let $o = (x\,|\,P)$ to represent a UTXO that holds value $x$ and lists a predicate $P$ that locks or unlocks this UTXO. Predicate $P$ can be a base predicate (see list below) or a combination of base predicates with $\lor$ (\textit{OR}) or $\land$ (\textit{AND}) operators.
\begin{itemize}
    \item $\sigma_a$: Signature that matches\footnote{Bitcoin uses SIGHASH flags to control which part of a transaction is signed by whom. For simplicity, we assume what is being signed is clear from the context.} the public key $A$.
    \item $s \ni h(s) = H_s$: The spending transaction needs to provide a preimage $s$ whose hashed value is $H_s$.
    \item $\Delta_k$: A timelock of $k$ blocks needs to elapse to unlock the spending transaction.
\end{itemize}
A transaction is a mapping from a set of past UTXO's to a set future UTXO's, and can be represented as:
$$T_i = [o_j, o_k, \ldots] \mapsto [o_i^1, o_i^2, \ldots]$$
where $T_i$ consumes past UTXO's $o_j$, $o_k$, $\ldots$. to produce future UTXO's $\{o_i^1$, $o_i^2$, $\ldots\}$. Predicates that apprear on the left side of a transaction unlock the UTXOs in question, and those that appear on the right side lock the newly created UTXO's. An example transaction would look like:
$$T_i = [(2\,|\sigma_a), \underbrace{(1\,|\,\Delta_{10}), (3\,|s_x)}_{T_j}] \mapsto [(6\,|\,\sigma_b \land H_{s_y})]$$
$T_i$ is spending 3 UTXO's by providing a signature $\sigma_a$ for $A$ (Alice), waiting for time $\Delta_{10}$ (10 blocks), and a preimage $s_x$ such that the hash $h(s_x)$ was used to lock the 3rd UTXO that $T_i$ is spending. $T_i$ itself creates a new UTXO that has the coin value of 6, and can be spent by providing a signature for $B$ (Bob) and a preimage $s_y$ such that the hash $h(s_y) = H_{s_y}$. Additionally, the two spent UTXO's $(1\,|\,\Delta_{10}), (3\,|s_x)$ were created in a previous transaction $T_j$. The UTXO creating transaction (in the underbrace) is shown only if it's relevant to the protocol. In the above case, the UTXO $(2|\sigma_a)$ doesn't show a source UTXO under it, and can be assumed that the transacton from where Alice got her 2 bitcoins doesn't matter in this setting. 

\section{Atomic Swaps}
Before Bitcoin, there was considerable research on the \textit{Fair Exchange Problem}, with its associated impossibility results \cite{cleve1986limits}, \cite{fair_exchange_impossibility}, \cite{franklin1997fair}, \cite{asokan1998optimistic}. Many of these results came about in the quest to remove the \textit{trusted third party} when two parties want to exchange different assets of equal value. Bitcoin created a different kind of trusted third party. Here, both parties trust the Bitcoin blockchain as an arbiter for dispute resolution and as a tamperproof public bulletin board. Fair Exchange, in the Bitcoin setting, is known as the Atomic Swap. It is atomic in the sense that a swap of assets between two parties either goes through fully or not at all. Atomic Swaps were perhaps the first non-trivial smart contracts designed to work on blockchains. Tier Nolan's classic swap (TN-swap, from here on) was discussed on the BitoinTalk forum in 2013 \cite{atomic_swap}. The TN-swap is not atomic from a transaction perspective. The swap requires 4 transactions: 2 HTLCs + (2 redeems or 2 refunds). The atomicity is from a higher abstraction of the swap of assets -- either the swap goes through, and both parties end up with the assets they desire, or it does not, and both parties retain their original assets. These assets could even be on different blockchains, e.g., Bitcoin and Litecoin. If it were a cross-chain atomic swap, both blockchains must be compatible with the primitives used in the swap protocol. 

In Tier Nolan's classic swap (TN-swap), Alice locks amount $P_a$ with a timelock (refunding $P_a$ back to her) and a hashlock (so Bob can redeem $P_a$). Bob locks amount $P_b$ symmetrically but with a lower value for the timelock. If one of the parties aborts, the other party can wait for their timelock to expire and refund their principals back to themselves. If neither party aborts, the swap completes with both parties redeeming the principals due to them. The blockchain acts as a public bulletin board that communicates the secret preimage of the hashlock from Alice to Bob. Alice's timelock is always longer than Bob's to account for Alice's head start in the protocol and knowing the preimage of the hashlock, which enables her to finish her side of the swap first. We use the word \textit{refund} when a party's principal comes back to them after a swap is abandoned, and the word \textit{redeem} when a party can complete a swap and get the counterparty's principal. The entire set of transactions that make up the TN-swap can be defined succinctly in our notation as shown in Figure \ref{fig:tier_nolan_atomic_swap}. Transactions are referred to as $T_i$. The set of transactions that make up the successful swap, and the two failure scenarious are also shown in the same figure.

\begin{figure}[hbt!]
    \centering
    \caption{Tier Nolan Atomic Swap}
    \label{fig:tier_nolan_atomic_swap}
\begin{align*}
    &T_0 = [(P_a|\sigma_a)] \mapsto [(P_a|(\sigma_a \land \Delta_2) \lor (\sigma_b \land H_{s}))] \\
    &T_1 = [(P_b|\sigma_b)] \mapsto [(P_b|(\sigma_a \land H_{s}) \lor (\sigma_b \land \Delta_1))] \\
    &T_2 = [\underbrace{(P_b|(\sigma_a \land s))}_{T_1}] \mapsto [(P_b|\sigma_a)]\\
    &T_3 = [\underbrace{(P_a|(\sigma_b \land s))}_{T_0}] \mapsto [(P_a|\sigma_b)]\\
    &T_4 = [\underbrace{(P_b|(\sigma_b \land \Delta_1))}_{T_1}] \mapsto [(P_b|(\sigma_b)] \\
    &T_5 = [\underbrace{(P_a|(\sigma_a \land \Delta_2))}_{T_1}] \mapsto [(P_a|(\sigma_a)] \\
    &Success = \{T_0, T_1, T_2, T_3\} \\
    &Failure_1 = \{T_0, T_5\} \\
    &\text{\parbox{8cm}{[Bob aborts before committing $P_b$. Alice has to wait for $\Delta_2$, and gets no compensation]}} \\
    &Failure_2 = \{T_0, T_1, T_4\} \\
    &\text{\parbox{8cm}{[Alice aborts before redeeming $P_b$. Bob has to wait for $\Delta_1$, and gets no compensation]}}
\end{align*}
\end{figure}

\section{Payment Channels and the Lightning Network}



